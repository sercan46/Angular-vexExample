import { Subject } from 'rxjs';
export function isFunction(target) {
    return typeof target === 'function';
}
/**
 * Applied to instances and stores `Subject` instance when
 * no custom destroy method is provided.
 */
const DESTROY = Symbol('__destroy');
/**
 * Applied to definitions and informs that class is decorated
 */
const DECORATOR_APPLIED = Symbol('__decoratorApplied');
/**
 * If we use the `untilDestroyed` operator multiple times inside the single
 * instance providing different `destroyMethodName`, then all streams will
 * subscribe to the single subject. If any method is invoked, the subject will
 * emit and all streams will be unsubscribed. We wan't to prevent this behavior,
 * thus we store subjects under different symbols.
 */
export function getSymbol(destroyMethodName) {
    if (typeof destroyMethodName === 'string') {
        return Symbol(`__destroy__${destroyMethodName}`);
    }
    else {
        return DESTROY;
    }
}
export function markAsDecorated(type) {
    // Store this property on the prototype if it's an injectable class, component or directive.
    // We will be able to handle class extension this way.
    type.prototype[DECORATOR_APPLIED] = true;
}
export function ensureClassIsDecorated(instance) {
    if (missingDecorator(instance.constructor)) {
        throw new Error('untilDestroyed operator cannot be used inside directives or ' +
            'components or providers that are not decorated with UntilDestroy decorator');
    }
}
export function createSubjectOnTheInstance(instance, symbol) {
    if (!instance[symbol]) {
        instance[symbol] = new Subject();
    }
}
export function completeSubjectOnTheInstance(instance, symbol) {
    if (instance[symbol]) {
        instance[symbol].next();
        instance[symbol].complete();
        // We also have to re-assign this property thus in the future
        // we will be able to create new subject on the same instance.
        instance[symbol] = null;
    }
}
function missingDecorator(type) {
    return !(DECORATOR_APPLIED in type.prototype);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJuYWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9pbnRlcm5hbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUkvQixNQUFNLFVBQVUsVUFBVSxDQUFDLE1BQWU7SUFDeEMsT0FBTyxPQUFPLE1BQU0sS0FBSyxVQUFVLENBQUM7QUFDdEMsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sT0FBTyxHQUFrQixNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7QUFFbkQ7O0dBRUc7QUFDSCxNQUFNLGlCQUFpQixHQUFrQixNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQUV0RTs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUsU0FBUyxDQUFJLGlCQUEyQjtJQUN0RCxJQUFJLE9BQU8saUJBQWlCLEtBQUssUUFBUSxFQUFFO1FBQ3pDLE9BQU8sTUFBTSxDQUFDLGNBQWMsaUJBQWlCLEVBQUUsQ0FBQyxDQUFDO0tBQ2xEO1NBQU07UUFDTCxPQUFPLE9BQU8sQ0FBQztLQUNoQjtBQUNILENBQUM7QUFFRCxNQUFNLFVBQVUsZUFBZSxDQUM3QixJQUE2RTtJQUU3RSw0RkFBNEY7SUFDNUYsc0RBQXNEO0lBQ3RELElBQUksQ0FBQyxTQUFTLENBQUMsaUJBQWlCLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDM0MsQ0FBQztBQVFELE1BQU0sVUFBVSxzQkFBc0IsQ0FBQyxRQUFhO0lBQ2xELElBQUksZ0JBQWdCLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxFQUFFO1FBQzFDLE1BQU0sSUFBSSxLQUFLLENBQ2IsOERBQThEO1lBQzVELDRFQUE0RSxDQUMvRSxDQUFDO0tBQ0g7QUFDSCxDQUFDO0FBRUQsTUFBTSxVQUFVLDBCQUEwQixDQUFDLFFBQWEsRUFBRSxNQUFjO0lBQ3RFLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDckIsUUFBUSxDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7S0FDeEM7QUFDSCxDQUFDO0FBRUQsTUFBTSxVQUFVLDRCQUE0QixDQUFDLFFBQWEsRUFBRSxNQUFjO0lBQ3hFLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1FBQ3BCLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN4QixRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDNUIsNkRBQTZEO1FBQzdELDhEQUE4RDtRQUM5RCxRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDO0tBQ3pCO0FBQ0gsQ0FBQztBQUVELFNBQVMsZ0JBQWdCLENBQ3ZCLElBQTZFO0lBRTdFLE9BQU8sQ0FBQyxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNoRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZVR5cGUsIMm1RGlyZWN0aXZlVHlwZSwgybVDb21wb25lbnRUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IFBpcGVUeXBlIH0gZnJvbSAnLi9pdnknO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih0YXJnZXQ6IHVua25vd24pIHtcbiAgcmV0dXJuIHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogQXBwbGllZCB0byBpbnN0YW5jZXMgYW5kIHN0b3JlcyBgU3ViamVjdGAgaW5zdGFuY2Ugd2hlblxuICogbm8gY3VzdG9tIGRlc3Ryb3kgbWV0aG9kIGlzIHByb3ZpZGVkLlxuICovXG5jb25zdCBERVNUUk9ZOiB1bmlxdWUgc3ltYm9sID0gU3ltYm9sKCdfX2Rlc3Ryb3knKTtcblxuLyoqXG4gKiBBcHBsaWVkIHRvIGRlZmluaXRpb25zIGFuZCBpbmZvcm1zIHRoYXQgY2xhc3MgaXMgZGVjb3JhdGVkXG4gKi9cbmNvbnN0IERFQ09SQVRPUl9BUFBMSUVEOiB1bmlxdWUgc3ltYm9sID0gU3ltYm9sKCdfX2RlY29yYXRvckFwcGxpZWQnKTtcblxuLyoqXG4gKiBJZiB3ZSB1c2UgdGhlIGB1bnRpbERlc3Ryb3llZGAgb3BlcmF0b3IgbXVsdGlwbGUgdGltZXMgaW5zaWRlIHRoZSBzaW5nbGVcbiAqIGluc3RhbmNlIHByb3ZpZGluZyBkaWZmZXJlbnQgYGRlc3Ryb3lNZXRob2ROYW1lYCwgdGhlbiBhbGwgc3RyZWFtcyB3aWxsXG4gKiBzdWJzY3JpYmUgdG8gdGhlIHNpbmdsZSBzdWJqZWN0LiBJZiBhbnkgbWV0aG9kIGlzIGludm9rZWQsIHRoZSBzdWJqZWN0IHdpbGxcbiAqIGVtaXQgYW5kIGFsbCBzdHJlYW1zIHdpbGwgYmUgdW5zdWJzY3JpYmVkLiBXZSB3YW4ndCB0byBwcmV2ZW50IHRoaXMgYmVoYXZpb3IsXG4gKiB0aHVzIHdlIHN0b3JlIHN1YmplY3RzIHVuZGVyIGRpZmZlcmVudCBzeW1ib2xzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3ltYm9sPFQ+KGRlc3Ryb3lNZXRob2ROYW1lPzoga2V5b2YgVCk6IHN5bWJvbCB7XG4gIGlmICh0eXBlb2YgZGVzdHJveU1ldGhvZE5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIFN5bWJvbChgX19kZXN0cm95X18ke2Rlc3Ryb3lNZXRob2ROYW1lfWApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBERVNUUk9ZO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXJrQXNEZWNvcmF0ZWQ8VD4oXG4gIHR5cGU6IEluamVjdGFibGVUeXBlPFQ+IHwgUGlwZVR5cGU8VD4gfCDJtURpcmVjdGl2ZVR5cGU8VD4gfCDJtUNvbXBvbmVudFR5cGU8VD5cbik6IHZvaWQge1xuICAvLyBTdG9yZSB0aGlzIHByb3BlcnR5IG9uIHRoZSBwcm90b3R5cGUgaWYgaXQncyBhbiBpbmplY3RhYmxlIGNsYXNzLCBjb21wb25lbnQgb3IgZGlyZWN0aXZlLlxuICAvLyBXZSB3aWxsIGJlIGFibGUgdG8gaGFuZGxlIGNsYXNzIGV4dGVuc2lvbiB0aGlzIHdheS5cbiAgdHlwZS5wcm90b3R5cGVbREVDT1JBVE9SX0FQUExJRURdID0gdHJ1ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVbnRpbERlc3Ryb3lPcHRpb25zIHtcbiAgYmxhY2tMaXN0Pzogc3RyaW5nW107XG4gIGFycmF5TmFtZT86IHN0cmluZztcbiAgY2hlY2tQcm9wZXJ0aWVzPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUNsYXNzSXNEZWNvcmF0ZWQoaW5zdGFuY2U6IGFueSk6IG5ldmVyIHwgdm9pZCB7XG4gIGlmIChtaXNzaW5nRGVjb3JhdG9yKGluc3RhbmNlLmNvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICd1bnRpbERlc3Ryb3llZCBvcGVyYXRvciBjYW5ub3QgYmUgdXNlZCBpbnNpZGUgZGlyZWN0aXZlcyBvciAnICtcbiAgICAgICAgJ2NvbXBvbmVudHMgb3IgcHJvdmlkZXJzIHRoYXQgYXJlIG5vdCBkZWNvcmF0ZWQgd2l0aCBVbnRpbERlc3Ryb3kgZGVjb3JhdG9yJ1xuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN1YmplY3RPblRoZUluc3RhbmNlKGluc3RhbmNlOiBhbnksIHN5bWJvbDogc3ltYm9sKTogdm9pZCB7XG4gIGlmICghaW5zdGFuY2Vbc3ltYm9sXSkge1xuICAgIGluc3RhbmNlW3N5bWJvbF0gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wbGV0ZVN1YmplY3RPblRoZUluc3RhbmNlKGluc3RhbmNlOiBhbnksIHN5bWJvbDogc3ltYm9sKTogdm9pZCB7XG4gIGlmIChpbnN0YW5jZVtzeW1ib2xdKSB7XG4gICAgaW5zdGFuY2Vbc3ltYm9sXS5uZXh0KCk7XG4gICAgaW5zdGFuY2Vbc3ltYm9sXS5jb21wbGV0ZSgpO1xuICAgIC8vIFdlIGFsc28gaGF2ZSB0byByZS1hc3NpZ24gdGhpcyBwcm9wZXJ0eSB0aHVzIGluIHRoZSBmdXR1cmVcbiAgICAvLyB3ZSB3aWxsIGJlIGFibGUgdG8gY3JlYXRlIG5ldyBzdWJqZWN0IG9uIHRoZSBzYW1lIGluc3RhbmNlLlxuICAgIGluc3RhbmNlW3N5bWJvbF0gPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1pc3NpbmdEZWNvcmF0b3I8VD4oXG4gIHR5cGU6IEluamVjdGFibGVUeXBlPFQ+IHwgUGlwZVR5cGU8VD4gfCDJtURpcmVjdGl2ZVR5cGU8VD4gfCDJtUNvbXBvbmVudFR5cGU8VD5cbik6IGJvb2xlYW4ge1xuICByZXR1cm4gIShERUNPUkFUT1JfQVBQTElFRCBpbiB0eXBlLnByb3RvdHlwZSk7XG59XG4iXX0=