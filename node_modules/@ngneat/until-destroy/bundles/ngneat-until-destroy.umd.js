(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@ngneat/until-destroy', ['exports', '@angular/core', 'rxjs', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.ngneat = global.ngneat || {}, global.ngneat['until-destroy'] = {}), global.ng.core, global.rxjs, global.rxjs.operators));
}(this, (function (exports, core, rxjs, operators) { 'use strict';

    var NG_PIPE_DEF = core.ɵNG_PIPE_DEF;
    function isPipe(target) {
        return !!target[NG_PIPE_DEF];
    }

    function isFunction(target) {
        return typeof target === 'function';
    }
    /**
     * Applied to instances and stores `Subject` instance when
     * no custom destroy method is provided.
     */
    var DESTROY = Symbol('__destroy');
    /**
     * Applied to definitions and informs that class is decorated
     */
    var DECORATOR_APPLIED = Symbol('__decoratorApplied');
    /**
     * If we use the `untilDestroyed` operator multiple times inside the single
     * instance providing different `destroyMethodName`, then all streams will
     * subscribe to the single subject. If any method is invoked, the subject will
     * emit and all streams will be unsubscribed. We wan't to prevent this behavior,
     * thus we store subjects under different symbols.
     */
    function getSymbol(destroyMethodName) {
        if (typeof destroyMethodName === 'string') {
            return Symbol("__destroy__" + destroyMethodName);
        }
        else {
            return DESTROY;
        }
    }
    function markAsDecorated(type) {
        // Store this property on the prototype if it's an injectable class, component or directive.
        // We will be able to handle class extension this way.
        type.prototype[DECORATOR_APPLIED] = true;
    }
    function ensureClassIsDecorated(instance) {
        if (missingDecorator(instance.constructor)) {
            throw new Error('untilDestroyed operator cannot be used inside directives or ' +
                'components or providers that are not decorated with UntilDestroy decorator');
        }
    }
    function createSubjectOnTheInstance(instance, symbol) {
        if (!instance[symbol]) {
            instance[symbol] = new rxjs.Subject();
        }
    }
    function completeSubjectOnTheInstance(instance, symbol) {
        if (instance[symbol]) {
            instance[symbol].next();
            instance[symbol].complete();
            // We also have to re-assign this property thus in the future
            // we will be able to create new subject on the same instance.
            instance[symbol] = null;
        }
    }
    function missingDecorator(type) {
        return !(DECORATOR_APPLIED in type.prototype);
    }

    function unsubscribe(property) {
        property && isFunction(property.unsubscribe) && property.unsubscribe();
    }
    function unsubscribeIfPropertyIsArrayLike(property) {
        Array.isArray(property) && property.forEach(unsubscribe);
    }
    function decorateNgOnDestroy(ngOnDestroy, options) {
        return function () {
            var _a;
            // Invoke the original `ngOnDestroy` if it exists
            ngOnDestroy && ngOnDestroy.call(this);
            // It's important to use `this` instead of caching instance
            // that may lead to memory leaks
            completeSubjectOnTheInstance(this, getSymbol());
            // Check if subscriptions are pushed to some array
            if (options.arrayName) {
                return unsubscribeIfPropertyIsArrayLike(this[options.arrayName]);
            }
            // Loop through the properties and find subscriptions
            if (options.checkProperties) {
                for (var property in this) {
                    if ((_a = options.blackList) === null || _a === void 0 ? void 0 : _a.includes(property)) {
                        continue;
                    }
                    unsubscribe(this[property]);
                }
            }
        };
    }
    function decorateProviderDirectiveOrComponent(type, options) {
        type.prototype.ngOnDestroy = decorateNgOnDestroy(type.prototype.ngOnDestroy, options);
    }
    function decoratePipe(type, options) {
        var def = type.ɵpipe;
        def.onDestroy = decorateNgOnDestroy(def.onDestroy, options);
    }
    function UntilDestroy(options) {
        if (options === void 0) { options = {}; }
        return function (type) {
            if (isPipe(type)) {
                decoratePipe(type, options);
            }
            else {
                decorateProviderDirectiveOrComponent(type, options);
            }
            markAsDecorated(type);
        };
    }

    function overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol) {
        var originalDestroy = instance[destroyMethodName];
        if (isFunction(originalDestroy) === false) {
            throw new Error(instance.constructor.name + " is using untilDestroyed but doesn't implement " + destroyMethodName);
        }
        createSubjectOnTheInstance(instance, symbol);
        instance[destroyMethodName] = function () {
            isFunction(originalDestroy) && originalDestroy.apply(this, arguments);
            completeSubjectOnTheInstance(this, symbol);
            // We have to re-assign this property back to the original value.
            // If the `untilDestroyed` operator is called for the same instance
            // multiple times, then we will be able to get the original
            // method again and not the patched one.
            instance[destroyMethodName] = originalDestroy;
        };
    }
    function untilDestroyed(instance, destroyMethodName) {
        return function (source) {
            var symbol = getSymbol(destroyMethodName);
            // If `destroyMethodName` is passed then the developer applies
            // this operator to something non-related to Angular DI system
            if (typeof destroyMethodName === 'string') {
                overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol);
            }
            else {
                ensureClassIsDecorated(instance);
                createSubjectOnTheInstance(instance, symbol);
            }
            return source.pipe(operators.takeUntil(instance[symbol]));
        };
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.UntilDestroy = UntilDestroy;
    exports.untilDestroyed = untilDestroyed;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngneat-until-destroy.umd.js.map
